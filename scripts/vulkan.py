#!/usr/bin/python2

import spec
import util
import os

spec.init()

ignored = util.functions_noop

layer_exports = [
	"vkGetInstanceProcAddr",
	"vkGetDeviceProcAddr",
	"vkGetPhysicalDeviceProcAddr",
	"vkEnumerateDeviceExtensionProperties",
	"vkEnumerateInstanceExtensionProperties",
	"vkEnumerateInstanceLayerProperties",
	"vkEnumerateDeviceLayerProperties",
	"vkdispatch_CreateInstance",
	"vkdispatch_CreateDevice"
]

w = open('generated/vulkan_layer.cpp', 'w')

class parameter(object):
	def __init__(self, node):
		raw = util.getraw(node)
		self.size = util.getsize(raw)
		self.name = node.find('name').text
		self.type = node.find('type').text
		self.mod = node.text
		if not self.mod:
			self.mod = ''
		self.const = 'const' in self.mod
		if self.const:
			self.mod = 'const '
		self.ptr = '*' in raw # is it a pointer?
		self.param_ptrstr = '* ' if self.ptr else ' '
		self.inline_ptrstr = '* ' if self.ptr else ' '
		if '**' in raw:
			self.param_ptrstr = '** '
		self.optional = node.attrib.get('optional')
		self.length = node.attrib.get('len') # eg 'null-terminated' or parameter name
		if not self.length and '[' in raw: # ie fixed length array
			length = node.find('enum')
			if length is not None:
				self.length = length.text
			else: # naked numeral
				self.length = raw.replace('[', '').replace(']', '')
		self.structure = self.type in spec.structures
		self.disphandle = self.type in spec.disp_handles
		self.nondisphandle = self.type in spec.nondisp_handles
		self.inparam = (not self.ptr or self.const) # else out parameter

	def parameter(self):
		if self.length and not self.ptr:
			return ('%s%s%s%s[%s]' % (self.mod, self.type, self.param_ptrstr, self.name, self.length)).strip()
		return ('%s%s%s%s' % (self.mod, self.type, self.param_ptrstr, self.name)).strip()

	def retrace_exec_param(self):
		return '%s' % self.name

def func_common(node):
	proto = node.find('proto')
	name = proto.find('name').text
	retval = proto.find('type').text
	if name in spec.protected_funcs:
		print >> w, '#ifdef %s // %s' % (spec.protected_funcs[name], name)
	params = []
	for p in node.findall('param'):
		params.append(parameter(p))
	paramlist = [ x.parameter() for x in params ]
	execlist = [ x.retrace_exec_param() for x in params ]
	return name, retval, params, paramlist, execlist

def func_common_end(name):
	if name in spec.protected_funcs:
		print >> w, '#endif // %s' % spec.protected_funcs[name]

print >> w, '// This file contains only code auto-generated by %s' % os.path.basename(__file__)
print >> w
print >> w, '#include "vulkan/vulkan.h"'
print >> w, '#include <jsoncpp/json/value.h>'
print >> w, '#include "util.h"'
print >> w, '#include "vk_wrapper_auto.h"'
print >> w, '#include "write_auto.h"'

# Add a few categories to the ignore list - don't care about desktop extensions for now
for v in spec.root.findall("commands/command"):
	if v.attrib.get('alias'):
		name = v.attrib.get('name')
	else:
		proto = v.find('proto')
		name = proto.find('name').text
	if spec.str_contains_vendor(name):
		ignored.append(name)

for node in spec.root.findall("commands/command"):
	if node.attrib.get('alias'): # may need to implement this...
		continue
	name, retval, params, paramlist, execlist = func_common(node)
	if name in layer_exports:
		print >> w
		if name in spec.disabled or name in ignored:
			func_common_end(name)
			continue
		print >> w, 'VK_LAYER_EXPORT VKAPI_ATTR %s VKAPI_CALL %s(%s)' % (retval, name, ', '.join(paramlist))
		print >> w, '{'
		if retval == 'void':
			print >> w, '\ttrace_%s(%s);' % (name, ', '.join(execlist))
		else:
			print >> w, '\treturn trace_%s(%s);' % (name, ', '.join(execlist))
		print >> w, '}'

	func_common_end(name)
