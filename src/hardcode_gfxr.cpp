// This file is special in that it is included into the autogenerated file, and not compiled as a separate unit.

static inline lava_file_writer& write_header(const char* funcname, lava_function_id id, int thread_index, bool thread_barrier = false)
{
	lava_writer& instance = lava_writer::instance();
	lava_file_writer& writer = instance.file_writer(thread_index);
	if (thread_barrier) { frame_mutex.lock(); writer.inject_thread_barrier(); frame_mutex.unlock(); }
	writer.write_api_command(id);
	writer.current.call_id = id;
	writer.current.frame = instance.global_frame;
	DLOG("[t%02u %06u] Seq %s%s", writer.current.thread, writer.current.call, funcname, thread_barrier ? " (prefaced by thread barrier)" : "");
	return writer;
}

static void common_vkGetPhysicalDeviceToolProperties(lava_file_writer& writer, VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolPropertiesEXT* pToolProperties)
{
	// -- Declarations --
	assert(physicalDevice != 0);
	const auto* physicaldevice_data = writer.parent->records.VkPhysicalDevice_index.at(physicalDevice);
	writer.write_handle(physicaldevice_data);
	writer.write_uint8_t((pToolProperties) ? 1 : 0);
	// -- Execute --
	// We assume anything passed to us is available to use, and will hide our filled out data to other layers, and assume they will do the same to us.
	if (pToolProperties != nullptr && *pToolCount > 0)
	{
		pToolProperties[0].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT;
		pToolProperties[0].pNext = nullptr;
		strcpy(pToolProperties[0].name, "lavatube");
		strcpy(pToolProperties[0].version, "0.0.1"); // TBD read from our defines
		pToolProperties[0].purposes = VK_TOOL_PURPOSE_TRACING_BIT_EXT | VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT | VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT | VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
		strcpy(pToolProperties[0].description, "Tracing layer");
		strcpy(pToolProperties[0].layer, "VK_LAYER_ARM_lavatube");
		pToolProperties = ((*pToolCount > 1) ? &pToolProperties[1] : nullptr); // hide our entry from any other layers being called so they don't overwrite it
		(*pToolCount)--;
	}
	// -- Post --
	writer.write_uint32_t(VK_SUCCESS);
}

void LavatubeConsumer::Process_vkGetPhysicalDeviceToolPropertiesEXT(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_physicalDevice, StructPointerDecoder<Decoded_uint32_t>* gfxr_pToolCount, StructPointerDecoder<Decoded_VkPhysicalDeviceToolProperties>* gfxr_pToolProperties)
{
	// Re-declaration
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	uint32_t* pToolCount = gfxr_pToolCount->GetPointer();
	VkPhysicalDeviceToolProperties* pToolProperties = (VkPhysicalDeviceToolProperties*)gfxr_pToolProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkGetPhysicalDeviceToolPropertiesEXT", VKGETPHYSICALDEVICETOOLPROPERTIESEXT);
	common_vkGetPhysicalDeviceToolProperties(writer, physicalDevice, pToolCount, pToolProperties);
	finish(writer);
}

void LavatubeConsumer::Process_vkGetPhysicalDeviceToolProperties(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_physicalDevice, StructPointerDecoder<Decoded_uint32_t>* gfxr_pToolCount, StructPointerDecoder<Decoded_VkPhysicalDeviceToolProperties>* gfxr_pToolProperties)
{
	// Re-declaration
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	uint32_t* pToolCount = gfxr_pToolCount->GetPointer();
	VkPhysicalDeviceToolProperties* pToolProperties = (VkPhysicalDeviceToolProperties*)gfxr_pToolProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkGetPhysicalDeviceToolProperties", VKGETPHYSICALDEVICETOOLPROPERTIES);
	common_vkGetPhysicalDeviceToolProperties(writer, physicalDevice, pToolCount, pToolProperties);
	finish(writer);
}

void LavatubeConsumer::Process_vkGetDeviceProcAddr(const ApiCallInfo& call_info, PFN_vkVoidFunction returnValue, format::HandleId gfxr_device, StructPointerDecoder<Decoded_char>* gfxr_pName)
{
	// Re-declaration
	VkDevice device = (VkDevice)gfxr_device;
	const char* pName = (const char*)gfxr_pName->GetPointer();
	// Declarations
	lava_writer& tracer = lava_writer::instance();
	lava_file_writer& writer = tracer.file_writer();
	DLOG2("Not tracing vkGetDeviceProcAddr(device, %s)", pName);
	return writer.parent->records.trace_getcall(pName);
}

void LavatubeConsumer::Process_vkGetInstanceProcAddr(const ApiCallInfo& call_info, PFN_vkVoidFunction returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_char>* gfxr_pName)
{
	// Re-declaration
	VkInstance instance = (VkInstance)gfxr_instance;
	const char* pName = (const char*)gfxr_pName->GetPointer();
	// Declarations
	lava_writer& tracer = lava_writer::instance();
	lava_file_writer& writer = tracer.file_writer();
	DLOG2("Not tracing vkGetInstanceProcAddr(instance, %s)", pName);
	return writer.parent->records.trace_getcall(pName);
}

void LavatubeConsumer::Process_vkGetSwapchainImagesKHR(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_device, format::HandleId gfxr_swapchain, StructPointerDecoder<Decoded_uint32_t>* gfxr_pSwapchainImageCount, HandlePointerDecoder<VkImage>* gfxr_pSwapchainImages)
{
	// Re-declaration
	VkDevice device = (VkDevice)gfxr_device;
	VkSwapchainKHR swapchain = (VkSwapchainKHR)gfxr_swapchain;
	uint32_t* pSwapchainImageCount = (uint32_t*)gfxr_pSwapchainImageCount->GetPointer();
	VkImage* pSwapchainImages = (VkImage*)gfxr_pSwapchainImages->GetPointer()
	// Declarations
	lava_file_writer& writer = start("vkGetSwapchainImagesKHR", VKGETSWAPCHAINIMAGESKHR);
	writer.write_handle(writer.parent->records.VkDevice_index.at(device));
	writer.write_handle(writer.parent->records.VkSwapchainKHR_index.at(swapchain));
	writer.write_uint8_t(pSwapchainImages ? 1 : 0);
	writer.write_uint32_t(returnValue);
	// Post
	writer.write_uint32_t(*pSwapchainImageCount);
	for (uint32_t i = 0; pSwapchainImages && i < *pSwapchainImageCount; i++)
	{
		writer.write_handle(writer.parent->records.VkImage_index.at(pSwapchainImages[i]));
	}
	// Return
	finish(writer);
	return retval;
}

void LavatubeConsumer::Process_vkCreateHeadlessSurfaceEXT(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_VkHeadlessSurfaceCreateInfoEXT>* gfxr_pCreateInfo, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator, HandlePointerDecoder<VkSurfaceKHR>* gfxr_pSurface)
{
	// Re-declarations
	VkInstance instance = (VkInstance)gfxr_instance;
	VkHeadlessSurfaceCreateInfoEXT* pCreateInfo = gfxr_pCreateInfo->GetPointer();
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	VkSurfaceKHR* pSurface = gfxr_pSurface->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkCreateHeadlessSurfaceEXT", VKCREATEHEADLESSSURFACEEXT);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	writer.write_uint32_t(pCreateInfo->sType);
	write_extension(writer, (VkBaseOutStructure*)pCreateInfo->pNext);
	writer.write_uint32_t(static_cast<uint32_t>(pCreateInfo->flags));
	writer.write_int32_t(0); // reserved
	writer.write_int32_t(0); // reserved
	writer.write_int32_t(0); // reserved
	writer.write_int32_t(0); // reserved
	writer.write_int32_t(0); // reserved
	writer.write_int32_t(0); // reserved
	// Execute
	writer.write_uint32_t(returnValue);
	// Post
	trackable* surface_data = writer.parent->records.VkSurfaceKHR_index.add(*pSurface, writer.current);
	DLOG("insert VkSurfaceKHR into vkCreateHeadlessSurfaceEXT index %u", (unsigned)surface_data->index);
	surface_data->enter_created();
	writer.write_handle(surface_data); // id tracking
	finish(writer);
}

#ifdef VK_USE_PLATFORM_XLIB_KHR // vkCreateXlibSurfaceKHR

void LavatubeConsumer::Process_vkCreateXlibSurfaceKHR(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_VkXlibSurfaceCreateInfoKHR>* gfxr_pCreateInfo, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator, HandlePointerDecoder<VkSurfaceKHR>* gfxr_pSurface)
{
	// -- Re-declarations --
	VkInstance instance = (VkInstance)gfxr_instance;
	VkXlibSurfaceCreateInfoKHR* pCreateInfo = gfxr_pCreateInfo->GetPointer();
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	VkSurfaceKHR* pSurface = gfxr_pSurface->GetPointer();
	// -- Declarations --
	uint8_t pCreateInfo_opt = 0;
	lava_file_writer& writer = start("vkCreateXlibSurfaceKHR", VKCREATEXLIBSURFACEKHR);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	writer.write_uint32_t(pCreateInfo->sType);
	assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR);
	write_extension(writer, (VkBaseOutStructure*)pCreateInfo->pNext);
	// Write out xlib info
	writer.write_uint32_t(static_cast<uint32_t>(pCreateInfo->flags));
	XWindowAttributes attr = {};
	Status s = XGetWindowAttributes(pCreateInfo->dpy, pCreateInfo->window, &attr);
	writer.write_int32_t(0); // x, TBD
	writer.write_int32_t(0); // y, TBD
	writer.write_int32_t(0); // width, TBD
	writer.write_int32_t(0); // height, TBD
	writer.write_int32_t(0); // border, TBD
	writer.write_int32_t(0); // depth, TBD
	writer.write_uint32_t(returnValue);
	// -- Post --
	trackable* surface_data = writer.parent->records.VkSurfaceKHR_index.add(*pSurface, writer.current);
	DLOG("insert VkSurfaceKHR into vkCreateXlibSurfaceKHR index %u", (unsigned)surface_data->index);
	surface_data->enter_created();
	writer.write_handle(surface_data); // id tracking
	finish(writer);
}

#endif // VK_USE_PLATFORM_XLIB_KHR 1

#ifdef VK_USE_PLATFORM_XCB_KHR // vkCreateXcbSurfaceKHR

void LavatubeConsumer::Process_vkCreateXcbSurfaceKHR(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_VkXcbSurfaceCreateInfoKHR>* gfxr_pCreateInfo, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator, HandlePointerDecoder<VkSurfaceKHR>* gfxr_pSurface)
{
	// -- Re-declarations --
	VkInstance instance = (VkInstance)gfxr_instance;
	VkXcbSurfaceCreateInfoKHR* pCreateInfo = gfxr_pCreateInfo->GetPointer();
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	VkSurfaceKHR* pSurface = gfxr_pSurface->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkCreateXcbSurfaceKHR", VKCREATEXCBSURFACEKHR);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	writer.write_uint32_t(pCreateInfo->sType);
	assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR);
	write_extension(writer, (VkBaseOutStructure*)pCreateInfo->pNext);
	writer.write_int32_t(0); // x, TBD
	writer.write_int32_t(0); // y, TBD
	writer.write_int32_t(0); // width, TBD
	writer.write_int32_t(0); // height, TBD
	writer.write_int32_t(0); // border, TBD
	writer.write_int32_t(0); // depth, TBD
	writer.write_uint32_t(returnValue);
	auto* surface_data = writer.parent->records.VkSurfaceKHR_index.add(*pSurface, writer.current);
	DLOG("insert VkSurfaceKHR into vkCreateXcbSurfaceKHR index %u", (unsigned)surface_data->index);
	surface_data->enter_created();
	writer.write_handle(surface_data); // id tracking
	finish(writer);
}

#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR // vkCreateWaylandSurfaceKHR

void LavatubeConsumer::Process_vkCreateWaylandSurfaceKHR(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_VkWaylandSurfaceCreateInfoKHR>* gfxr_pCreateInfo, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator, HandlePointerDecoder<VkSurfaceKHR>* gfxr_pSurface)
{
	// Re-declarations
	VkInstance instance = (VkInstance)gfxr_instance;
	VkWaylandSurfaceCreateInfoKHR* pCreateInfo = gfxr_pCreateInfo->GetPointer();
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	VkSurfaceKHR* pSurface = gfxr_pSurface->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkCreateWaylandSurfaceKHR", VKCREATEWAYLANDSURFACEKHR);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	writer.write_uint32_t(pCreateInfo->sType);
	assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR);
	write_extension(writer, (VkBaseOutStructure*)pCreateInfo->pNext);
	writer.write_uint32_t(static_cast<uint32_t>(pCreateInfo->flags));
	writer.write_int32_t(0); // x, TBD
	writer.write_int32_t(0); // y, TBD
	writer.write_int32_t(0); // width, TBD
	writer.write_int32_t(0); // height, TBD
	writer.write_int32_t(0); // border, reserved
	// TBD missing depth
	// Execute
	writer.write_uint32_t(returnValue);
	// Post
	auto* surface_data = writer.parent->records.VkSurfaceKHR_index.add(*pSurface, writer.current);
	surface_data->enter_created();
	writer.write_handle(surface_data); // id tracking
	finish(writer);
}

#endif // VK_USE_PLATFORM_WAYLAND_KHR

void LavatubeConsumer::Process_vkDestroySurfaceKHR(const ApiCallInfo& call_info, format::HandleId gfxr_instance, format::HandleId gfxr_surface, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator)
{
	// -- Re-declarations --
	VkInstance instance = (VkInstance)gfxr_instance;
	VkSurfaceKHR surface = (VkSurfaceKHR)gfxr_surface;
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	// Declarations
	uint8_t surface_opt;
	lava_file_writer& writer = start("vkDestroySurfaceKHR", VKDESTROYSURFACEKHR);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	surface_opt = (surface != 0); // whether we should load this optional value
	writer.write_uint8_t(surface_opt);
	if (surface_opt)
	{
		const auto* surface_data = writer.parent->records.VkSurfaceKHR_index.unset(surface, writer.current);
		writer.write_handle(surface_data);
	}
	finish(writer);
}

/// Map virtual queue to real queue. Since we cannot reverse map from one family to two, the two graphics queues must be on the same
/// family, and we only check the first one.
static void internalGetDeviceQueue(const std::vector<VkQueueFamilyProperties>& props, uint32_t queueIndex, uint32_t& realIndex, uint32_t& realFamily)
{
	realFamily = 0;
	for (const auto& f : props)
	{
		if (f.queueFlags & VK_QUEUE_GRAPHICS_BIT)
		{
			assert(queueIndex <= 1);
			if (queueIndex == 0) realIndex = 0; // real first queue
			else if (queueIndex == 1 && f.queueCount == 1) realIndex = 0; // fake second queue redirecting to first real queue
			else realIndex = 1; // real second queue
			return;
		}
		realFamily++;
	}
}

void LavatubeConsumer::Process_vkGetDeviceQueue2(const ApiCallInfo& call_info, format::HandleId gfxr_device, StructPointerDecoder<Decoded_VkDeviceQueueInfo2>* gfxr_pQueueInfo, HandlePointerDecoder<VkQueue>* gfxr_pQueue)
{
	// Re-declarations
	VkDevice device = (VkDevice)gfxr_device;
	VkDeviceQueueInfo2* pQueueInfo = (VkDeviceQueueInfo2*)gfxr_pQueueInfo->GetPointer();
	VkQueue* pQueue = (VkQueue*)gfxr_pQueue->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkGetDeviceQueue2", VKGETDEVICEQUEUE2);
	writer.write_handle(writer.parent->records.VkDevice_index.at(device));
	trackeddevice* device_data = writer.parent->records.VkDevice_index.at(device);
	trackedphysicaldevice* physicaldevice_data = writer.parent->records.VkPhysicalDevice_index.at(device_data->physicalDevice);
	writer.physicalDevice = device_data->physicalDevice;
	writer.device = device;
	VkDeviceQueueInfo2* pQueueInfo = writer.pool.allocate<VkDeviceQueueInfo2>(1);
	*pQueueInfo = *pQueueInfo_orig;
	write_VkDeviceQueueInfo2(writer, pQueueInfo);
	if (!writer.parent->records.VkQueue_index.contains(*pQueue))
	{
		auto* queue_data = writer.parent->records.VkQueue_index.add(*pQueue, writer.current);
		queue_data->queueIndex = pQueueInfo->queueIndex;
		queue_data->queueFamily = pQueueInfo->queueFamilyIndex;
		queue_data->queueFlags = pQueueInfo->flags;
		queue_data->device = device;
		queue_data->realIndex = pQueueInfo->queueIndex;
		queue_data->realFamily = pQueueInfo->queueFamilyIndex;
		queue_data->realQueue = *pQueue;
		queue_data->physicalDevice = device_data->physicalDevice;
		queue_data->enter_initialized();
	}
	auto* queue_data = writer.parent->records.VkQueue_index.at(*pQueue);
	assert(queue_data);
	if (p__virtualqueues != 0) *pQueue = (VkQueue)queue_data;
	queue_data->self_test();
	writer.write_handle(queue_data);
	finish(writer);
}

void LavatubeConsumer::Process_vkGetDeviceQueue(const ApiCallInfo& call_info, format::HandleId gfxr_device, uint32_t queueFamilyIndex, uint32_t queueIndex, HandlePointerDecoder<VkQueue>* gfxr_pQueue)
{
	// Re-declarations
	VkDevice device = (VkDevice)gfxr_device;
	VkQueue* pQueue = gfxr_pQueue->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkGetDeviceQueue", VKGETDEVICEQUEUE);
	auto* device_data = writer.parent->records.VkDevice_index.at(device);
	trackedphysicaldevice* physicaldevice_data = writer.parent->records.VkPhysicalDevice_index.at(device_data->physicalDevice);

	writer.write_handle(device_data);
	writer.write_uint32_t(queueFamilyIndex);
	writer.write_uint32_t(queueIndex);

	// Post
	if (!writer.parent->records.VkQueue_index.contains(*pQueue))
	{
		auto* queue_data = writer.parent->records.VkQueue_index.add(*pQueue, writer.current);
		queue_data->queueIndex = queueIndex;
		queue_data->queueFamily = queueFamilyIndex;
		queue_data->queueFlags = physicaldevice_data->queueFamilyProperties.at(queueFamilyIndex).queueFlags;
		queue_data->device = device;
		queue_data->realIndex = queueIndex;
		queue_data->realFamily = queueFamilyIndex;
		queue_data->realQueue = *pQueue;
		queue_data->physicalDevice = device_data->physicalDevice;
		queue_data->enter_initialized();
	}
	auto* queue_data = writer.parent->records.VkQueue_index.at(*pQueue);
	assert(queue_data);
	queue_data->self_test();
	writer.write_handle(queue_data);
	finish(writer);
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR // vkCreateAndroidSurfaceKHR

#include "android_utils.h"

void LavatubeConsumer::Process_vkCreateAndroidSurfaceKHR(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_instance, StructPointerDecoder<Decoded_VkAndroidSurfaceCreateInfoKHR>* gfxr_pCreateInfo, StructPointerDecoder<Decoded_VkAllocationCallbacks>* gfxr_pAllocator, HandlePointerDecoder<VkSurfaceKHR>* gfxr_pSurface)
{
	// Re-declarations
	VkInstance instance = (VkInstance)gfxr_instance;
	VkAndroidSurfaceCreateInfoKHR* pCreateInfo = gfxr_pCreateInfo->GetPointer();
	VkAllocationCallbacks* pAllocator = gfxr_pAllocator->GetPointer();
	VkSurfaceKHR* pSurface = gfxr_pSurface->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkCreateAndroidSurfaceKHR", VKCREATEANDROIDSURFACEKHR);
	writer.write_handle(writer.parent->records.VkInstance_index.at(instance));
	writer.write_uint32_t(pCreateInfo->sType);
	assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR);
	write_extension(writer, (VkBaseOutStructure*)pCreateInfo->pNext);
	writer.write_uint32_t(static_cast<uint32_t>(pCreateInfo->flags));
	writer.write_int32_t(0); // x position - TBD
	writer.write_int32_t(0); // y position - TBD
	writer.write_int32_t(0); // width
	writer.write_int32_t(0); // height
	writer.write_int32_t(0); // border
	writer.write_int32_t(0); // depth
	// Post
	const auto* surface_data = writer.parent->records.VkSurfaceKHR_index.add(*pSurface, writer.current);
	surface_data->enter_created();
	writer.write_handle(surface_data); // id tracking
	// TBD write out return value??
	finish(writer);
}

static uint32_t bytes_per_pixel(uint32_t format)
{
	switch (format) {
		case AHARDWAREBUFFER_FORMAT_BLOB:
		case AHARDWAREBUFFER_FORMAT_S8_UINT:
			return 1;
		case AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM:
		case AHARDWAREBUFFER_FORMAT_D16_UNORM:
			return 2;
		case AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM:
		case AHARDWAREBUFFER_FORMAT_D24_UNORM:
			return 3;
		case AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM:
		case AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM:
		case AHARDWAREBUFFER_FORMAT_D24_UNORM_S8_UINT:
		case AHARDWAREBUFFER_FORMAT_R10G10B10A2_UNORM:
		case AHARDWAREBUFFER_FORMAT_D32_FLOAT:
			return 4;
		case AHARDWAREBUFFER_FORMAT_D32_FLOAT_S8_UINT:
			return 5;
		case AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT:
			return 8;
	}

	return 0;
}

static void save_hw_buffer(const AHardwareBuffer* buffer)
{
	lava_file_writer& writer = lava_writer::instance().file_writer();
	AHardwareBuffer_Desc hw_buffer_description;
	AHardwareBuffer_describe(buffer, &hw_buffer_description);

	uint32_t bpp = bytes_per_pixel(hw_buffer_description.format);

	writer.write_uint32_t(hw_buffer_description.width);
	writer.write_uint32_t(hw_buffer_description.height);
	writer.write_uint32_t(hw_buffer_description.layers);
	writer.write_uint32_t(hw_buffer_description.format);
	writer.write_uint64_t(hw_buffer_description.usage);
	writer.write_uint32_t(hw_buffer_description.stride);
	writer.write_uint32_t(hw_buffer_description.rfu0);
	writer.write_uint64_t(hw_buffer_description.rfu1);
	writer.write_uint32_t(bpp);
}

void LavatubeConsumer::Process_vkGetAndroidHardwareBufferPropertiesANDROID(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_device, StructPointerDecoder<Decoded_AHardwareBuffer>* gfxr_buffer, StructPointerDecoder<Decoded_VkAndroidHardwareBufferPropertiesANDROID>* gfxr_pProperties)
{
	// Re-declarations
	VkDevice device = (VkDevice)gfxr_device;
	AHardwareBuffer* buffer = gfxr_buffer->GetPointer();
	VkAndroidHardwareBufferPropertiesANDROID* pProperties = gfxr_pProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkGetAndroidHardwareBufferPropertiesANDROID", VKGETANDROIDHARDWAREBUFFERPROPERTIESANDROID);
	writer.write_handle(writer.parent->records.VkDevice_index.at(device));
	// Store metadata for debug purposes
	save_hw_buffer(buffer);
	// Post
	writer.write_uint32_t(returnValue);
	writer.write_uint32_t(pProperties->sType);
	assert(pProperties->sType == VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID);
	write_extension(writer, (VkBaseOutStructure*)pProperties->pNext);
	writer.write_uint64_t(pProperties->allocationSize);
	writer.write_uint32_t(pProperties->memoryTypeBits);
	finish(writer);
}

void LavatubeConsumer::Process_vkGetMemoryAndroidHardwareBufferANDROID(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_device, StructPointerDecoder<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>* gfxr_pInfo, StructPointerDecoder<Decoded_AHardwareBuffer>** gfxr_pBuffer)
{
	// -- Re-declarations --
	VkDevice device = (VkDevice)gfxr_device;
	VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo = gfxr_pInfo->GetPointer();
	AHardwareBuffer* pBuffer = gfxr_pBuffer->GetPointer();
	// Declarations
	const dummy_ext* ext_tmp_VVkMemoryGetAndroidHardwareBufferInfoANDROID = nullptr;
	lava_file_writer& writer = start("vkGetMemoryAndroidHardwareBufferANDROID", VKGETMEMORYANDROIDHARDWAREBUFFERANDROID);
	writer.write_handle(writer.parent->records.VkDevice_index.at(device));
	writer.write_uint32_t(pInfo->sType);
	assert(pInfo->sType == VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID);
	write_extension(writer, (VkBaseOutStructure*)pInfo->pNext);
	writer.write_handle(writer.parent->records.VkDeviceMemory_index.at(pInfo->memory));
	// Execute
	writer.write_uint32_t(returnValue);
	// Store metadata for debug purposes
	save_hw_buffer(*pBuffer);
	finish(writer);
}

#endif // VK_USE_PLATFORM_ANDROID_KHR

void LavatubeConsumer::Process_vkEnumerateInstanceLayerProperties(const ApiCallInfo& call_info, VkResult returnValue, StructPointerDecoder<Decoded_uint32_t>* gfxr_pPropertyCount, StructPointerDecoder<Decoded_VkLayerProperties>* gfxr_pProperties)
{
	// Re-declarations
	uint32_t* pPropertyCount = gfxr_pPropertyCount->GetPointer();
	VkLayerProperties* pProperties = gfxr_pProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkEnumerateInstanceLayerProperties", VKENUMERATEINSTANCELAYERPROPERTIES);
	writer.write_uint8_t(pProperties ? 1 : 0);
	writer.write_uint32_t(returnValue);
	finish(writer);
}

void LavatubeConsumer::Process_vkEnumerateInstanceExtensionProperties(const ApiCallInfo& call_info, VkResult returnValue, StructPointerDecoder<Decoded_char>* gfxr_pLayerName, StructPointerDecoder<Decoded_uint32_t>* gfxr_pPropertyCount, StructPointerDecoder<Decoded_VkExtensionProperties>* gfxr_pProperties)
{
	// Re-declarations
	char* pLayerName = gfxr_pLayerName->GetPointer();
	uint32_t* pPropertyCount = gfxr_pPropertyCount->GetPointer();
	VkExtensionProperties* pProperties = gfxr_pProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkEnumerateInstanceExtensionProperties", VKENUMERATEINSTANCEEXTENSIONPROPERTIES);
	writer.write_string(pLayerName);
	writer.write_uint8_t(pProperties ? 1 : 0);
	// Execute
	writer.write_uint32_t(returnValue);
	finish(writer);
}

void LavatubeConsumer::Process_vkEnumerateDeviceLayerProperties(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_physicalDevice, StructPointerDecoder<Decoded_uint32_t>* gfxr_pPropertyCount, StructPointerDecoder<Decoded_VkLayerProperties>* gfxr_pProperties)
{
	// Re-declarations
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	uint32_t* pPropertyCount = gfxr_pPropertyCount->GetPointer();
	VkLayerProperties* pProperties = gfxr_pProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkEnumerateDeviceLayerProperties", VKENUMERATEDEVICELAYERPROPERTIES);
	uint8_t initialized = static_cast<uint8_t>(writer.parent->records.VkPhysicalDevice_index.contains(physicalDevice));
	writer.write_uint8_t(initialized);
	if (initialized)
	{
		writer.write_handle(writer.parent->records.VkPhysicalDevice_index.at(physicalDevice));
	}
	writer.write_uint8_t(pProperties ? 1 : 0);
	writer.write_uint32_t(returnValue);
	finish(writer);
}

void LavatubeConsumer::Process_vkEnumerateDeviceExtensionProperties(const ApiCallInfo& call_info, VkResult returnValue, format::HandleId gfxr_physicalDevice, StructPointerDecoder<Decoded_char>* gfxr_pLayerName, StructPointerDecoder<Decoded_uint32_t>* gfxr_pPropertyCount, StructPointerDecoder<Decoded_VkExtensionProperties>* gfxr_pProperties);
{
	// Re-declarations
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	const char* pLayerName = (const char*)gfxr_pLayerName->GetPointer();
	uint32_t* pPropertyCount = (uint32_t*)gfxr_pPropertyCount->GetPointer();
	VkExtensionProperties* pProperties = (VkExtensionProperties*)gfxr_pProperties->GetPointer();
	// Declarations
	lava_file_writer& writer = start("vkEnumerateDeviceExtensionProperties", VKENUMERATEDEVICEEXTENSIONPROPERTIES);
	uint8_t initialized = static_cast<uint8_t>(writer.parent->records.VkPhysicalDevice_index.contains(physicalDevice));
	writer.write_uint8_t(initialized);
	if (initialized)
	{
		writer.write_handle(writer.parent->records.VkPhysicalDevice_index.at(physicalDevice));
	}

	writer.write_string(pLayerName);
	writer.write_uint8_t(pProperties ? 1 : 0);
	writer.write_uint32_t(VK_SUCCESS);
	finish(writer);
}

#ifdef VK_USE_PLATFORM_XLIB_KHR // vkCreateXlibSurfaceKHR
void LavatubeConsumer::Process_vkGetPhysicalDeviceXlibPresentationSupportKHR(const ApiCallInfo& call_info, VkBool32 returnValue, format::HandleId gfxr_physicalDevice, uint32_t queueFamilyIndex, uint64_t dpy, size_t visualID)
{
	// Re-declarations
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	// Declarations
	lava_file_writer& writer = start("vkGetPhysicalDeviceXlibPresentationSupportKHR", VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR);
	trackedphysicaldevice* physicaldevice_data = writer.parent->records.VkPhysicalDevice_index.at(physicalDevice);
	writer.write_handle(physicaldevice_data);
	writer.write_uint32_t(queueFamilyIndex);
	writer.write_uint32_t(returnValue);
	finish(writer);
}
#endif

void LavatubeConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties(const ApiCallInfo& call_info, format::HandleId gfxr_physicalDevice, StructPointerDecoder<Decoded_uint32_t>* gfxr_pQueueFamilyPropertyCount, StructPointerDecoder<Decoded_VkQueueFamilyProperties>* gfxr_pQueueFamilyProperties);
{
	// Re-declaration
	VkPhysicalDevice physicalDevice = (VkPhysicalDevice)gfxr_physicalDevice;
	uint32_t* pQueueFamilyPropertyCount = (uint32_t*)gfxr_pQueueFamilyPropertyCount->GetPointer();
	VkQueueFamilyProperties* pQueueFamilyProperties = (VkQueueFamilyProperties*)gfxr_pQueueFamilyProperties->GetPointer();
	// Declaration
	lava_file_writer& writer = start("vkGetPhysicalDeviceQueueFamilyProperties", VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES);
	trackedphysicaldevice* physicaldevice_data = writer.parent->records.VkPhysicalDevice_index.at(physicalDevice);
	writer.write_handle(physicaldevice_data);
	writer.write_uint8_t((pQueueFamilyProperties) ? 1 : 0);
	finish(writer);
}
